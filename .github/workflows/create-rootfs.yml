#  create-rootfs.yml
#  Created: 2024/09/15 - 08:10
#  Altered: qua 18 fev 2026 13:20:00 -04
#  Version: 1.3.6
#
#  Copyright (c) 2024-2026, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
##############################################################################
name: Build ROOTFS VoidBR

on:
  push:
    branches:
      - main
  repository_dispatch:
    types:
      - "ISO-*"
  workflow_dispatch:
    inputs:
      name:
        type: string
        description: "Name for the ROOTFS"
        required: true
        default: "voidbr"
      edition:
        type: choice
        description: "Edition"
        options:
          - base-minimal
          - base-system
          - base-voidstrap
          - base-custom
        default: "base-custom"
      tmate:
        type: boolean
        description: "Enable debugging with tmate"
        required: false
        default: false

  schedule:
    - cron: "0 7 * * *"

env:
  TELEGRAM_TOKEN: "${{ secrets.TOKEN_BOT }}"
  TELEGRAM_VOIDBR_ROOTFS_TOKEN_BOT: "${{ secrets.VOIDBR_ROOTFS_TOKEN_BOT }}"
  GITHUB_TOKEN: "${{ secrets.ORGANIZATION_TOKEN }}"
  CHAT_ID: "${{ secrets.CHAT_ID }}"
  MESSAGE_THREAD_ID: "${{ secrets.MESSAGE_THREAD_ID }}"
  MESSAGE_THREAD_ID_ROOTFS: "${{ secrets.MESSAGE_THREAD_ID_ROOTFS }}"
  started_by_user: "${{ github.actor }}"
  triggered_by_user: "${{ github.triggering_actor }}"
  DEBUG: "${{ github.event.client_payload.tmate || inputs.tmate || false }}"
  tmate: "${{ github.event.client_payload.tmate || inputs.tmate || false }}"
  iso_distroname: "${{ github.event.client_payload.distroname || inputs.distroname || 'voidBR' }}"
  edition: "${{ github.event.client_payload.edition || inputs.edition || 'base-custom' }}"
  rootfs_name: "void-x86_64-${{ github.event.client_payload.edition || inputs.edition || 'base-custom' }}-current.tar.xz"
  wf_url: "https://github.com/${{ github.repository }}/blob/main/.github/workflows/create-rootfs.yml"
  wf_file: "create-rootfs.yml"

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      time: ${{ steps.time.outputs.time }} # Sa√≠da do job
      REPOSITORY_NAME: ${{ steps.get-repo-name.outputs.repo_name }}
    steps:
      - name: Obter a hora atual
        id: time
        shell: bash
        run: |
          #Obter a hora atual
          echo "time=$(date +'%Y.%m.%d-%H%M')" >> $GITHUB_OUTPUT

      - name: Capturar hora de in√≠cio do workflow
        id: start-time
        shell: bash
        run: |
          START_TIME=$(date +"%Y-%m-%d %H:%M:%S")  # Hora completa
          START_TIMESTAMP=$(date +%s)  # Timestamp em segundos
          echo "In√≠cio do Workflow: $START_TIME"
          echo "START_TIME=$START_TIME"             >> $GITHUB_ENV
          echo "START_TIMESTAMP=$START_TIMESTAMP"   >> $GITHUB_ENV
          echo "START_TIME='$START_TIME'"           >> shared_file.txt
          echo "START_TIMESTAMP='$START_TIMESTAMP'" >> shared_file.txt

      - name: Create Global Helpers Script - Definir a fun√ß√£o send_telegram_message no script tempor√°rio
        shell: bash
        env:
          TELEGRAM_TOKEN: "${{ inputs.telegram_token }}"
          TELEGRAM_CHAT_ID: "${{ inputs.telegram_chat_id }}"
          TELEGRAM_VOIDBR_ROOTFS_TOKEN_BOT: "${{ inputs.voidbr_rootfs_token_bot }}"
          TELEGRAM_MESSAGE_THREAD_ID_ROOTFS: "${{ inputs.telegram_message_thread_id_rootfs }}"
        run: |
          #Definir a fun√ß√£o send_telegram_message no script tempor√°rio
          sudo rm -rf /tmp/send_telegram_message.sh  # Remove se for diret√≥rio
          cat << 'EOF' > /tmp/send_telegram_message.sh
          export TERM=${TERM:-xterm}
          export TERM=${TERM:-xterm-256color}

          #Definindo vari√°veis de cores
          export reset="\033[0m"
          export rst="\033[0m"
          export green="\033[01;32m"
          export red="\033[01;31m"
          export blue="\033[01;34m"
          export cyan="\033[01;36m"
          export pink="\033[01;35m"
          export yellow="\033[01;33m"
          alias ls='ls -lha --color=auto'
          alias dir='ls -lha --color=auto'

          die() {
            local msg="$1"
            msg="$(sed 's/<[^>]*>//g' <<< "$msg")" # Remove as tags HTML
            echo -e "BP=>${cyan}error: ${red}${msg}${reset}"
            exit  1
          }
          export -f die

          msg() {
            local msg="$1"
            msg="$(sed 's/<[^>]*>//g' <<< "$msg")" # Remove as tags HTML
            echo -e "BIV=>${cyan}running: ${yellow}${msg}${reset}"
          }

          msg_tab() {
            local msg="$1"
            msg="$(sed 's/<[^>]*>//g' <<< "$msg")" # Remove as tags HTML
            echo -e "BIV=>${yellow}info   : ${cyan}${msg}${reset}"
          }

          msg_raw() {
            local msg="$1"
            # Remove tags HTML, se existirem
            #msg="$(sed 's/<[^>]*>//g' <<< "$msg")"

            # Verifica se existe ':' na mensagem
            if [[ "$msg" == *:* ]]; then
              # Divide a string antes e depois do primeiro ':'
              local before_colon="${msg%%:*}:"
              local after_colon="${msg#*: }"
              # Aplica as cores
              msg="${cyan}${before_colon} ${yellow}${after_colon}${reset}"
            else
              # Se n√£o houver ':', aplica apenas a cor padr√£o
              msg="${cyan}${msg}${reset}"
            fi
            echo -e "$msg"
          }
          export -f msg_raw

          msg_ok() {
            local msg="$1"
            msg="$(sed 's/<[^>]*>//g' <<< "$msg")" # Remove as tags HTML
            echo -e "BP=>${cyan}feito  : ${green}${msg}${reset}"
          }
          export -f msg_ok

          msg_run() {
            local msg="$1"
            echo -e "BP=>${cyan}running: ${yellow}${msg}${reset}"

            # Executa o comando e captura o c√≥digo de sa√≠da
            if ! eval "$msg"; then
              echo -e "BP=>${red}Erro ao executar: ${yellow}${msg}${reset}" >&2
              return 1
            fi
            return 0
          }
          export -f msg_run

          msg_info() {
            local msg="$1"
            msg="$(sed 's/<[^>]*>//g' <<< "$msg")" # Remove as tags HTML
            echo -e "BIV=>${yellow}info   : ${cyan}${msg}${reset}"
          }

          msg_warning() {
            local msg="$1"
            msg="$(sed 's/<[^>]*>//g' <<< "$msg")" # Remove as tags HTML
            echo -e "BIV=>${red}warning: ${orange}${msg}${reset}"
          }

          replicate() {
            local char=${1:-'#'}
            local nsize=${2:-$(tput cols)}
            local line
            #printf -v line "%*s" "$nsize" && echo "${line// /$char}"
            #printf -v line "%*s" "$nsize" && echo -e "\033[31m${line// /$char}\033[0m"
            printf -v line "%*s" "$nsize" && echo -e "${blue}${line// /$char}${reset}"
          }
          export -f replicate

          function send_telegram_message() {
            local message="$1"
            local parse_mode="$2"

            # Define parse_mode como "MarkdownV2" se n√£o for especificado
            [[ -z $parse_mode ]] && parse_mode="HTML"

            link_action=https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}
            DOWNLOAD_LINK="<a href='${D_URL}'>${FILE_NAME}</a>"
            <b>Job           :</b> <code>#${GITHUB_RUN_NUMBER}</code>
            <b>Job URL       :</b> <a href='${link_action}'>${link_action}</a>
            <b>Workflow file :</b> <a href='${wf_url}'>${wf_file}</a>
            <b>Triggered     :</b> <code>${started_by_user}/${triggered_by_user}</code>
            <b>Started       :</b> <code>${START_TIME}</code>
            <b>Distroname    :</b> <code>${iso_distroname}</code>
            <b>Edition       :</b> <code>${edition}</code>
            <b>Kernel Host   :</b> <code>x86_64/${KERNEL_HOST}</code>
            <b>Tmate         :</b> <code>${{ env.DEBUG }}</code>
            <b>FileName      :</b> <code>${rootfs_name}</code>"

            # Remove as tags HTML e exibe o resultado no terminal
            echo -e "${green}$(sed 's/<[^>]*>//g' <<< "$MESSAGE")${reset}"
            # Envia a mensagem original com HTML para o Telegram
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_VOIDBR_ROOTFS_TOKEN_BOT}/sendMessage" \
              -d chat_id="${CHAT_ID}" \
              -d message_thread_id="${MESSAGE_THREAD_ID_ROOTFS}" \
              -d text="${MESSAGE}" \
              -d parse_mode="HTML"
          }
          export -f send_telegram_message
          EOF
          chmod +x /tmp/send_telegram_message.sh

      - name: Enviar notifica√ß√£o inicial para o Telegram
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          msg "- name: Enviar notifica√ß√£o inicial para o Telegram"
          MESSAGE="üöÄ <b>[step 1/2] - INICIANDO WORKFLOW</b>"
          send_telegram_message "${MESSAGE}"

      - name: Install dependencies in HOST
        shell: bash
        run: |
          source /tmp/send_telegram_message.sh
          replicate
          msg "-name: Install dependencies in HOST"
          #sudo apt-get update
          #sudo apt-get autoremove
          #sudo apt-get install -y inetutils-tools duf tree tmate
          sudo apt-get install -y inetutils-tools duf tree
          replicate

      #      - name: Setup TMATE Session in HOST
      #        uses: mxschmitt/action-tmate@v3
      #        shell: bash
      #        with:
      #          install-dependencies: false
      #          detached: true

      - name: Pegar Vers√£o do Kernel do Host (ubuntu)
        shell: bash
        run: |
          KVER=$(uname -a)
          echo "KERNEL_HOST=${KVER}" >> $GITHUB_ENV

      - name: Set up volume directory in HOST
        shell: bash
        run: |
          #Set up volume directory in HOST
          sudo mkdir -p /mnt/var_lib_manjaro_tools_buildiso
          sudo mkdir -p /mnt/var_cache_manjaro_tools_iso
          sudo mkdir -p /mnt/lfs

      - name: Upload script as artifact
        uses: actions/upload-artifact@v4
        with:
          name: telegram-script
          path: /tmp/send_telegram_message.sh

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: shared-file
          path: shared_file.txt

  build:
    name: Build void-x86_64-${{ github.event.client_payload.edition || 'base-custom' }}
    runs-on: ubuntu-latest
    needs: [setup]
    container:
      #image: vcatafesta/voidlinux-docker:1.5
      image: vcatafesta/voidlinux:1.5           # seg 23 fev 2026 11:55:31 -04
      options: --privileged
      volumes:
        - /mnt/var_lib_manjaro_tools_buildiso:/var/lib/manjaro-tools/buildiso
        - /mnt/var_cache_manjaro_tools_iso:/var/cache/manjaro-tools/iso
        - /mnt/lfs:/mnt/lfs

    steps:
      - name: Download Telegram Script
        uses: actions/download-artifact@v4
        with:
          name: telegram-script
          path: /tmp/ # O download-artifact vai colocar o arquivo em /tmp/send_telegram_message.sh dentro do container

      - name: Download artifact shared-file
        uses: actions/download-artifact@v4
        with:
          name: shared-file

      - name: Capturar hora de in√≠cio real
        run: |
          echo "S_TIME_HUMAN=$(date +'%Y-%m-%d %H:%M:%S')" >> $GITHUB_ENV
          echo "S_TIMESTAMP=$(date +%s)" >> $GITHUB_ENV

      - name: Checkout repository (voidbr-build-rootfs)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Build ROOTFS Void
        uses: ./
        id: build
        with:
          name: ${{ github.event.client_payload.name || inputs.name }}
          tmate: ${{ github.event.client_payload.tmate || 'false' }}
          github_token: ${{ secrets.ORGANIZATION_TOKEN }}
          message_thread_id_rootfs: ${{ secrets.MESSAGE_THREAD_ID_ROOTFS }}

      - name: Capturar dados da tarball rootfs gerado
        run: |
          # O rootfs √© constru√≠do dentro da pasta da edi√ß√£o (ex: base-custom)
          #TARGET_ROOT="${{ env.WORK_PATH }}/${{ env.edition }}"
          TARGET_ROOT="${{ env.PROFILE_PATH }}/${{ env.edition }}"
          PKG_LIST_NAME="packages-${{ env.edition }}.txt"

          # Gera a lista de pacotes
          xbps-query -r "$TARGET_ROOT" -l | awk '{print $2}' > "${{ env.WORK_PATH }}/$PKG_LIST_NAME"

          # Exporta o nome do arquivo para usar no link do Telegram
          echo "PKG_LIST_FILE=$PKG_LIST_NAME" >> $GITHUB_ENV

          # 1. Contar Pacotes do ROOTFS real
          PKG_COUNT=$(xbps-query -r "$TARGET_ROOT" -l 2>/dev/null | wc -l || echo "0")
          echo "TOTAL_PACKAGES=${PKG_COUNT}" >> $GITHUB_ENV

          # 2. Pega a vers√£o do pacote linux instalado no rootfs real
          K_VER=$(xbps-query -r "$TARGET_ROOT" -p version linux 2>/dev/null || echo "na")
          echo "REAL_KERNEL=${K_VER}" >> $GITHUB_ENV

          # 3. Pega o kernel do container
          K_CONTAINER=$(uname -a)
          echo "CONTAINER_KERNEL=${K_CONTAINER}" >> $GITHUB_ENV

      - name: Calculate MD5 Hash
        shell: bash
        run: |
          pushd "${{ env.WORK_PATH }}"
          md5sum "${{ env.XZ_BASENAME }}" > "${{ env.XZ_BASENAME }}.md5"
          # Captura o hash e salva no GITHUB_ENV para uso posterior
          echo "MD5_VAL=$(cut -d' ' -f1 "${{ env.XZ_BASENAME }}.md5")" >> $GITHUB_ENV
          popd

      - name: Prepare ZIP file for release
        id: prepare-iso
        shell: bash
        run: |
          #Prepare ZIP file for release
          source /tmp/send_telegram_message.sh
          msg_run "ls -lha $PWD"
          release=${{ env.XZ_BASENAME }} # Apenas obt√©m o nome do arquivo com extens√£o
          release="${release%.tar.xz}"
          echo "release_name=${release}" >> $GITHUB_ENV
          if zip \
              --junk-paths \
              --store \
              -s 2000m \
              ${release}.zip \
              ${{ env.XZ_FULLNAME }} \
              ${{ env.XZ_FULLNAME }}.md5 \
              packages-${{ env.edition }}.txt; then
            echo "ZIP_FULLNAME=${{ env.WORK_PATH }}/${release}.zip" >> "$GITHUB_ENV"
            echo "ZIP_BASENAME=${release}.zip"                      >> "$GITHUB_ENV"
            echo "${ZIP_FULLNAME} prepared for release"
            msg_run "ls -lha $PWD"
          else
            die "ERRO: No preparo do arquivo ZIP para release"
          fi

      - name: Criar Release e Upload Asset
        id: create_gh_release
        uses: softprops/action-gh-release@v2
        with:
          #tag_name: ${{ env.XZ_TAG_NAME }}
          tag_name: ${{ github.run_id }}_zip
          release_name: Release ${{ needs.get-time.outputs.time }}_zip
          files: |
            ${{ env.XZ_FULLNAME }}
            ${{ env.WORK_PATH }}/${{ env.XZ_BASENAME }}.md5
            ${{ env.WORK_PATH }}/packages-${{ env.edition }}.txt
          body: |
            - **Data e Hora        :** ${{ needs.get-time.outputs.time }}
            - **Nome do Reposit√≥rio:** ${{ env.REPO_NAME }}
            - Auto-generated build
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.ORGANIZATION_TOKEN }}

      - name: Atualizar reposit√≥rio void-install
        shell: bash
        run: |
          git clone --depth=1 https://x-access-token:${{ secrets.ORGANIZATION_TOKEN }}@github.com/voidlinuxbr/void-install.git "${{ env.WORK_PATH }}/void-install"
          cd "${{ env.WORK_PATH }}/void-install"
          cp -fv "${{ env.XZ_FULLNAME }}" void-x86_64-base-custom-current.tar.xz
          cp -fv "${{ env.XZ_FULLNAME }}.md5" void-x86_64-base-custom-current.tar.xz.md5
          sed -i "s/${{ env.XZ_BASENAME }}/void-x86_64-base-custom-current.tar.xz/g" void-x86_64-base-custom-current.tar.xz.md5
          git config --global user.email "vctafesta@gmail.com"
          git config --global user.name "GitHub Actions"
          git add .
          git commit -m "Gerado e adicionado automaticamente pelo Github Actions"
          git push origin main

      - name: Enviar notifica√ß√£o final para o Telegram
        if: always()
        shell: bash
        env:
          D_URL: "https://github.com/${{ github.repository }}/releases/download/${{ env.XZ_TAG_NAME }}/${{ env.XZ_BASENAME }}"
          P_URL: "https://github.com/${{ github.repository }}/releases/download/${{ env.XZ_TAG_NAME }}/${{ env.PKG_LIST_FILE }}"
          FILE_NAME: ${{ env.XZ_BASENAME }}
          PKG_FILE: ${{ env.PKG_LIST_FILE }}
          START_T: ${{ env.S_TIME_HUMAN }}
          START_TS: ${{ env.S_TIMESTAMP }}
        run: |
          # Enviar notifica√ß√£o final para o Telegram
          END_TS=$(date +%s)
          DURATION=$((END_TS - START_TS))
          MIN=$((DURATION / 60))
          SEC=$((DURATION % 60))

          FILE_SIZE="N/A"
          if [[ -f "${{ env.XZ_FULLNAME }}" ]]; then
            FILE_SIZE=$(du -h "${{ env.XZ_FULLNAME }}" | cut -f1)
          fi

          STATUS="${{ job.status }}"
          if [[ "$STATUS" == "success" ]]; then
            EMOJI="‚úÖ"
            TEXT_STATUS="CONCLU√çDO COM SUCESSO"
            DOWNLOAD_LINK="<a href='${D_URL}'>${FILE_NAME}</a>"
            PACKAGES_LINK="<a href='${P_URL}'>${PKG_FILE}</a>"
          else
            EMOJI="‚ùå"
            TEXT_STATUS="FALHOU"
            DOWNLOAD_LINK="N/A"
            PACKAGES_LINK="N/A"
          fi

          link_action=https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}
          DISK_FREE=$(df -h / | awk 'NR==2 {print $4}')
          MESSAGE="${{ github.workflow }} ${EMOJI} <b>[step 2/2] - ${TEXT_STATUS}</b>
          <b>Job           :</b> <code>#${GITHUB_RUN_NUMBER}</code>
          <b>Job URL       :</b> <a href='${link_action}'>${link_action}</a>
          <b>Workflow file :</b> <code>create-rootfs.yml</code>
          <b>Status        :</b> <code>${STATUS}</code>
          <b>Started       :</b> <code>${START_T}</code>
          <b>Triggered     :</b> <code>${started_by_user}/${triggered_by_user}</code>
          <b>Edition       :</b> <code>${edition}</code>
          <b>Kernel        :</b> <code>${{env.REAL_KERNEL}}</code>
          <b>Duration      :</b> <code>${MIN}m ${SEC}s</code>
          <b>Disk free     :</b> <code>${DISK_FREE}</code>
          <b>MD5           :</b> <code>${{ env.MD5_VAL }}</code>
          <b>Download      :</b> ${DOWNLOAD_LINK}
          <b>Size          :</b> <code>${FILE_SIZE}</code>
          <b>Packages      :</b> ${PACKAGES_LINK} (<code>${{ env.TOTAL_PACKAGES }}</code>)"

          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_VOIDBR_ROOTFS_TOKEN_BOT}/sendMessage" \
            -d chat_id="${CHAT_ID}" \
            -d message_thread_id="${MESSAGE_THREAD_ID_ROOTFS}" \
            -d text="${MESSAGE}" \
            -d parse_mode="HTML"
